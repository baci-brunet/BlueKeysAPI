service: bluekeys
frameworkVersion: "3"

provider:
  name: aws
  runtime: python3.12
  region: us-east-1
  stage: ${opt:stage, 'dev'}
  architecture: x86_64
  environment:
    CORS_ALLOWED_ORIGINS: "*"
    STAGE: ${self:provider.stage}
    JWT_AUDIENCE: ${env:JWT_AUDIENCE}           
    CLERK_ISSUER_URL: ${env:CLERK_ISSUER_URL}   
    CLERK_JWKS_URL: ${env:CLERK_JWKS_URL}      
    # Database (RDS MySQL)
    DB_HOST: ${env:DB_HOST}
    DB_PORT: ${env:DB_PORT, '3306'}
    DB_USER: ${env:DB_USER}
    DB_PASSWORD: ${env:DB_PASSWORD}
    DB_NAME: ${env:DB_NAME}
  iamManagedPolicies:
    - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
          Resource: "*"
        - Effect: Allow
          Action:
            - ec2:CreateNetworkInterface
            - ec2:DescribeNetworkInterfaces
            - ec2:DeleteNetworkInterface
            - ec2:DescribeSubnets
            - ec2:DescribeSecurityGroups
            - ec2:DescribeVpcs
          Resource: "*"

functions:
  # Lambda Authorizer
  jwtAuthorizer:
    handler: src/authorizer/authorizer.lambda_handler
    timeout: 10
    environment:
      CLERK_JWKS_URL: ${self:provider.environment.CLERK_JWKS_URL}
      CLERK_ISSUER: ${self:provider.environment.CLERK_ISSUER_URL}
      JWT_AUDIENCE: ${self:provider.environment.JWT_AUDIENCE}

  # Public route (no auth)
  health:
    handler: src/handlers/health.get
    events:
      - http:
          path: health
          method: get
          cors:
              origins: ${self:custom.cors.origins}
              headers: ${self:custom.cors.headers}
              allowCredentials: ${self:custom.cors.allowCredentials}

  # Protected route (requires Lambda Authorizer)
  getReports:
    handler: src/handlers/reports.get
    vpc:
      securityGroupIds:
        - ${env:LAMBDA_SECURITY_GROUP_ID}
      subnetIds:
        - ${env:LAMBDA_SUBNET_ID_1}
        - ${env:LAMBDA_SUBNET_ID_2}
    timeout: 29
    events:
      - http:
          path: reports
          method: get
          authorizer:
            name: jwtAuthorizer
            type: token
            identitySource: method.request.header.Authorization
          cors:
            origins: ${self:custom.cors.origins}
            headers: ${self:custom.cors.headers}
            allowCredentials: ${self:custom.cors.allowCredentials}
  
  getProfileInfo:
    handler: src/handlers/profile.post
    vpc:
      securityGroupIds:
        - ${env:LAMBDA_SECURITY_GROUP_ID}
      subnetIds:
        - ${env:LAMBDA_SUBNET_ID_1}
        - ${env:LAMBDA_SUBNET_ID_2}
    timeout: 29
    events:
      - http:
          path: profile
          method: post
          authorizer:
            name: jwtAuthorizer
            type: token
            identitySource: method.request.header.Authorization
          cors:
            origins: ${self:custom.cors.origins}
            headers: ${self:custom.cors.headers}
            allowCredentials: ${self:custom.cors.allowCredentials}

package:
  patterns:
    - "!**/*"
    - "src/**"
    - "requirements.txt"

plugins:
  - serverless-python-requirements

custom:
  pythonRequirements:
    dockerizePip: true
    slim: true
    strip: false
    useStaticCache: true
    useDownloadCache: true
  
  cors:
    origins:
      - "*"
    headers:
      - Content-Type
      - Authorization
    allowCredentials: false            # you're using Bearer tokens, not cookies
